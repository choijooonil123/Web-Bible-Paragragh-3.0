<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Web Bible Paragraph Sermon</title>
  <style>
    :root{
      --bg:#0f1115; --panel:#161922; --text:#e6e8ef; --muted:#9aa0ab;
      --accent:#6ea8fe; --border:#252a36; --danger:#ff6b6b; --titleBlue:#9fd0ff;
    }
    *{ box-sizing:border-box } html,body{ height:100% }
    body{
      margin:0; font-family:system-ui,-apple-system,"Segoe UI",Roboto,"Noto Sans KR",sans-serif;
      background:var(--bg); color:var(--text);
      display:grid; grid-template-rows:64px 1fr; gap:10px;
    }
    header{
      display:flex; align-items:center; gap:10px; padding:8px 10px;
      background:var(--panel); border-bottom:1px solid var(--border);
      position:sticky; top:0; z-index:5;
    }
    header h1{ font-size:16px; margin:0; font-weight:700 }
    .muted{ color:var(--muted) }
    .pill{
      display:flex; gap:8px; align-items:center; border:1px solid var(--border);
      background:color-mix(in hsl, var(--panel) 80%, black 8%); padding:6px 8px; border-radius:10px;
    }
    select, input[type="range"]{ background:transparent; color:var(--text); border:1px solid var(--border); border-radius:8px; padding:4px 6px }
    option{ color:#000 }
    button{
      background:color-mix(in hsl, var(--panel) 65%, black 10%); color:var(--text);
      border:1px solid var(--border); border-radius:10px; padding:6px 10px; cursor:pointer;
      transition:border-color .15s, transform .04s;
    }
    button:hover{ border-color:color-mix(in hsl, var(--border) 80%, var(--accent) 20%) }
    button:active{ transform:translateY(1px) }
    .primary{
      background:linear-gradient(180deg,color-mix(in srgb, var(--accent) 75%, white 10%), color-mix(in srgb, var(--accent) 75%, black 20%));
      border-color:color-mix(in srgb, var(--accent) 70%, black 10%);
    }

    .layout{ display:grid; grid-template-columns:1fr; gap:10px; padding:0 10px 12px }
    .card{ background:var(--panel); border:1px solid var(--border); border-radius:14px; overflow:hidden; display:flex; flex-direction:column; min-width:0 }
    .scroller{ overflow:auto; padding:12px }
    .footer{ padding:8px 12px; border-top:1px solid var(--border); display:flex; align-items:center; justify-content:space-between; gap:8px; flex-wrap:wrap }

    #tree{ padding:8px }
    details{
      border:1px solid var(--border); border-radius:10px; padding:6px 8px; margin-bottom:8px;
      background:color-mix(in hsl, var(--panel) 80%, black 8%);
    }
    summary{ cursor:pointer; list-style:none; display:flex; align-items:center; gap:8px }
    summary::-webkit-details-marker{ display:none }
    .tw{ font-weight:700 }
    .chapters{ display:grid; gap:6px; margin-top:6px }
    .paras{ display:grid; gap:6px; margin:8px 0 2px }
    .chip{
      font-size:.92em; padding:6px 10px; border:1px solid var(--border); border-radius:999px;
      display:inline-flex; align-items:center; gap:6px; background:color-mix(in hsl, var(--panel) 88%, black 4%); white-space:nowrap;
    }
    .chip:hover{ border-color:var(--accent) }
    .ptitle{ font-weight:800; color:var(--titleBlue) }
    .vrange{ color:var(--muted); font-weight:700 }

    .pbody{ margin-top:8px; border-top:1px dashed var(--border); padding-top:8px }
    .ptoolbar{ display:flex; gap:8px; align-items:center; flex-wrap:wrap; margin-bottom:8px }

    /* 설교 버튼이 가려지거나 사라지는 것 방지 */
    .ptoolbar .spacer { flex: 1 1 auto; }
    .ptoolbar .sermBtn { display: inline-flex; }

    .pline{ padding:4px 6px; border-left:3px solid transparent; border-radius:8px; transition: background .15s, border-color .15s }
    .pline:hover{ background:color-mix(in hsl, var(--panel) 80%, black 12%) }
    .pline.reading{ background:color-mix(in hsl, var(--accent) 15%, black 0%); border-left-color:var(--accent) }
    .pv{ color:var(--muted); font-size:.88em; vertical-align:super; margin-right:4px }

    .modal-backdrop{ position:fixed; inset:0; background:rgba(0,0,0,.45); display:none; align-items:center; justify-content:center; z-index:50 }
    .modal{ width:min(1200px, 96vw); max-height:94vh; overflow:auto; background:var(--panel); border:1px solid var(--border); border-radius:14px }
    .modal .head{
      position:sticky; top:0; background:var(--panel); padding:12px 14px;
      display:flex; gap:10px; align-items:center; border-bottom:1px solid var(--border)
    }
    .list{ padding:12px 14px; display:grid; gap:8px }
    .item{ border:1px solid var(--border); border-radius:10px; padding:6px 10px; display:flex; justify-content:space-between; align-items:center; gap:10px; flex-wrap:wrap }
    .item-title{ font-weight:700; color:var(--titleBlue); line-height:1.15; display:flex; align-items:center; gap:8px; flex-wrap:wrap }
    .item-title .date{ margin-left:8px; color:var(--muted); font-weight:400; font-size:.92em }

    .editor{ padding:14px; display:grid; gap:12px; background:var(--panel) }
    .editor input[type="text"], .editor textarea{ width:100%; background:#161922; color:#e6e8ef; border:1px solid #2a3040; border-radius:8px; padding:10px 12px }
    .editor textarea{ min-height:360px; resize:vertical }
    .editor-bar{ display:flex; gap:8px; align-items:center; flex-wrap:wrap }
    .editor-bar .grow{ flex:1 1 auto }

    /* [맥락 편집기 전용] 보기 좋은 타이포/레이아웃 */
    .context-editor {
      font-family: "Noto Serif KR", "Nanum Myeongjo", serif;
      font-size: 1.05rem;
      line-height: 1.85;
      letter-spacing: 0.02em;
      word-break: keep-all;
      background: var(--panel);
      color: var(--text);
      border-radius: 12px;
      box-shadow: 0 6px 16px rgba(0,0,0,0.25);
    }
    .context-editor input[type="text"]{
      font-family: "Noto Serif KR", "Nanum Myeongjo", serif;
      font-weight: 600;
      font-size: 1.12rem;
      letter-spacing: 0.01em;
    }
    .context-editor .rte{
      min-height:360px;resize:vertical;padding:14px;background:#161922;border:1px solid #2a3040;border-radius:10px;line-height:1.85;letter-spacing:.015em;caret-color:var(--accent);outline:none
    }
    .context-editor em,.context-editor strong,.context-editor b{
      color:#ffd66e;font-weight:600;font-style:normal
    }
    .context-editor blockquote{
      margin:12px 0;padding:10px 14px;border-left:3px solid var(--accent);
      color:#c0cad6;font-style:italic;background:rgba(255,255,255,.04);border-radius:8px
    }
    .context-editor ::selection{background:rgba(110,168,254,.25)}
    @media (max-width:640px){.context-editor{font-size:1rem}}
    @media (prefers-color-scheme:light){
      .context-editor{color:#1b2533;background:#fff;box-shadow:0 6px 16px rgba(0,0,0,.08)}
      .context-editor blockquote{color:#445066;background:#f7f9fc}
    }

    /* 모달 편집기 타이트 모드 */
    #sermonEditor.context-editor .rte{
      line-height: 1.55 !important;
      letter-spacing: 0.01em !important;
    }
    #sermonEditor.context-editor .rte p{ margin: 6px 0; }
    #sermonEditor.context-editor .rte .verse-line{ line-height: 1.5; }
    #sermonEditor.context-editor .rte .verse-line sup{ margin-right:4px; }
    #sermonEditor.context-editor .rte br{ line-height: 1.0; }

    /* 모달 편집기: 본문만 스크롤 */
    #sermonEditor{
      display:flex; flex-direction:column;
      height: calc(94vh - 56px); min-height: calc(94vh - 56px); max-height: calc(94vh - 56px);
      overflow: hidden;
    }
    #sermonEditor .rte {
      flex: 1 1 auto;
      min-height: 0;
      overflow-y: auto;
      padding-top: var(--editor-pad-top, 0px);
      margin-top: 0 !important;
      scroll-padding-top: var(--editor-pad-top, 0px);
    }

    /* RTE 툴바 고정 */
    #rteToolbar {
      position: sticky;
      top: 0;
      z-index: 10;
      background: var(--panel);
      border-bottom: 1px solid var(--border);
    }

    /* 삽입된 성경구절 스타일 */
    .inserted-verse { font-style: italic; color: #ff8080; }
    .verse-header { margin-bottom:2px; }
    .verse-line { font-style: italic; color:#ff8080; }

    /* 설교목록 링크 필드 */
    .link-box{
      display:flex; align-items:center; gap:6px; min-width:260px; flex:1 1 320px;
    }
    .link-box input{
      flex:1 1 auto; min-width:200px;
      background:#161922;color:#e6e8ef;border:1px solid #2a3040;border-radius:8px;padding:6px 8px
    }
    .link-box a{
      text-decoration:underline; color:#9fd0ff; word-break:break-all;
      max-width:280px; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;
    }
    .ptoolbar .sermBtn{ margin-left:auto }

    /* 응급: 설교 버튼 가시성 강제 */
    .ptoolbar .sermBtn { display:inline-flex !important; visibility:visible !important; opacity:1 !important; }

    /* === 절문장 서식 툴바 === */
    #wbp-plbar{
      position: fixed; left:0; top:0;
      transform: translate(-50%, calc(-100% - 10px));
      background:#0f1320; border:1px solid var(--border, #252a36);
      border-radius:10px; padding:6px;
      display:flex; gap:6px; align-items:center;
      box-shadow:0 8px 20px rgba(0,0,0,.35); z-index:9999;
    }
    #wbp-plbar[hidden]{ display:none; }
    #wbp-plbar .divider{ width:1px; height:20px; background:var(--border, #252a36); }
    #wbp-plbar button{
      border:1px solid var(--border, #252a36); background:#1f2533; color:#e6e8ef;
      padding:6px 8px; border-radius:8px; cursor:pointer; font-weight:700;
    }
    #wbp-plbar button:hover{ background:#273046; }
    #wbp-plbar input[type="color"]{
      width:28px; height:28px; padding:0; border:1px solid var(--border, #252a36);
      background:#1f2533; border-radius:6px; cursor:pointer;
    }
    /* 편집 모드 표시 */
    details.para .pcontent[contenteditable="true"]{
      outline: 1px dashed #3b4b7a; outline-offset: 2px;
    }

    /* ==== 컨텐츠가 채워진 버튼 시각 강조 ==== */
    .ptoolbar button.filled {
      background: color-mix(in hsl, var(--accent) 25%, var(--panel) 65%);
      border-color: var(--accent);
      box-shadow: 0 0 0 2px color-mix(in hsl, var(--accent) 35%, transparent 65%) inset;
      color: #fff;
      border-width: 1px;
      box-shadow: 0 0 6px rgba(0,0,0,0.25);
    }
    .ptoolbar button.filled::after{
      content: "●";
      font-size: 10px;
      margin-left: 6px;
      opacity: .8;
      color: rgba(255,255,255,0.85);
    }

    /* 버튼별 채워짐(filled) 색상 구분 */
    .ptoolbar .btnSummary.filled    { background:#6a5acd; border-color:#7b68ee; }   /* 내용흐름-보라 */
    .ptoolbar .btnUnitCtx.filled    { background:#9370db; border-color:#b48cf0; }   /* 단위-연보라 */
    .ptoolbar .btnWholeCtx.filled   { background:#4682b4; border-color:#5ca5e5; }   /* 전체-파랑 */
    .ptoolbar .btnCommentary.filled { background:#3cb371; border-color:#58d68d; }   /* 주석-초록 */
    .ptoolbar .sermBtn.filled       { background:#ff8c00; border-color:#ffa94d; }   /* 설교-주황 */

    .ptoolbar button {
      transition: background 0.25s ease, border-color 0.25s ease, color 0.25s ease;
    }

    /* 색상 스와치 버튼 */
    #wbp-plbar .color-swatch{
      width:22px; height:22px; border-radius:6px; border:1px solid var(--border, #252a36);
      display:inline-block; cursor:pointer; outline:none;
    }
    #wbp-plbar .color-swatch:focus{ box-shadow:0 0 0 2px rgba(255,255,255,.15) inset; }
    #wbp-plbar select{
      height:28px; border-radius:6px; border:1px solid var(--border, #252a36);
      background:#1f2533; color:#e6e8ef; padding:0 6px; cursor:pointer;
    }

  </style>

  <link href="https://fonts.googleapis.com/css2?family=Noto+Serif+KR:wght@400;600&family=Nanum+Myeongjo&display=swap" rel="stylesheet">
</head>
<body>
  <header>
    <h1>Web Bible Paragraph 3.0</h1>

    <div class="pill"><button id="btnSaveJSON">JSON 저장</button></div>

    <div class="pill">
      <button id="btnExportAll">내보내기</button>
      <input id="importFile" type="file" accept="application/json" style="display:none">
      <button id="btnImportAll">가져오기</button>
    </div>

    <div class="pill">
      <span class="muted">음성</span>
      <select id="voiceSelect" title="한국어 보이스 선택">
        <option value="">브라우저 기본(ko-KR)</option>
      </select>
      <button id="testVoice">시험</button>
    </div>

    <div class="pill">
      <span class="muted">속도</span>
      <input id="rateCtl" type="range" min="0.6" max="1.4" step="0.02" value="0.95" />
      <span class="muted">톤</span>
      <input id="pitchCtl" type="range" min="0.6" max="1.4" step="0.02" value="1.00" />
    </div>

    <div class="pill" id="voiceHint" style="display:none">
      <span class="muted">한국어 보이스가 1개뿐이라 스타일 프리셋을 추가했습니다.</span>
    </div>

    <div style="flex:1"></div>
    <div class="pill"><span class="muted">단축키:</span> <span> S</span> 재생/중지 <span> · N</span> 다음 단락</div>
  </header>

  <div class="layout">
    <section class="card">
      <div class="scroller"><div id="tree"></div></div>
      <div class="footer"><div class="muted" id="status">bible-paragraph.json을 불러오는 중…</div></div>
    </section>
  </div>

  <div id="modalWrap" class="modal-backdrop" aria-hidden="true">
    <div class="modal">
      <div class="head">
        <strong id="modalTitle">단락 성경</strong>
        <span class="muted" id="modalRef">—</span>
        <div class="grow"></div>
        <button id="closeModal">닫기</button>
      </div>

      <div class="list" id="sermonList"></div>

      <!-- 단일 편집기 -->
      <div class="editor context-editor" id="sermonEditor" style="display:none">
        <div id="rteToolbar" class="editor-bar">
          <button type="button" onclick="execFmt('bold')"><b>B</b></button>
          <button type="button" onclick="execFmt('italic')"><i>I</i></button>
          <button type="button" onclick="execFmt('underline')"><u>U</u></button>
          <button type="button" onclick="execFmt('strikeThrough')"><s>S</s></button>
          <div class="grow"></div>
        </div>

        <input id="sermonTitle" type="text" placeholder="제목" style="display:none" />
        <div id="sermonBody" class="rte" contenteditable="true" spellcheck="false"></div>

        <div class="editor-bar">
          <div class="grow"></div>
          <button id="editorSpeak" class="primary">낭독</button>
          <button id="saveSermon" class="primary">저장</button>
        </div>
      </div>

      <div id="modalFooterNew" class="footer" style="padding:10px 14px; border-top:1px solid var(--border)">
        <button id="newSermonBtn" class="primary">새 설교</button>
      </div>
    </div>
  </div>

  <!-- 플로팅 서식툴바: 절(.pline) 선택 시에만 표시 -->
  <!-- 플로팅 서식툴바: 절(.verse) 선택 시에만 표시 -->
  <div id="wbp-plbar" hidden role="toolbar" aria-label="절 서식">
    <button type="button" data-cmd="bold" title="굵게 (Ctrl+B)"><b>B</b></button>
    <button type="button" data-cmd="italic" title="기울임 (Ctrl+I)"><i>I</i></button>
    <button type="button" data-cmd="underline" title="밑줄 (Ctrl+U)"><u>U</u></button>
  
    <div class="divider"></div>
  
    <!-- 6가지 고정 색상 스와치 -->
    <button type="button" class="color-swatch" style="background:#e03131" data-color="#e03131" title="빨강"></button>
    <button type="button" class="color-swatch" style="background:#f08c00" data-color="#f08c00" title="주황"></button>
    <button type="button" class="color-swatch" style="background:#fab005" data-color="#fab005" title="노랑"></button>
    <button type="button" class="color-swatch" style="background:#2f9e44" data-color="#2f9e44" title="초록"></button>
    <button type="button" class="color-swatch" style="background:#1971c2" data-color="#1971c2" title="파랑"></button>
    <button type="button" class="color-swatch" style="background:#7048e8" data-color="#7048e8" title="보라"></button>
  
    <!-- 기타 색상: 드롭다운 -->
    <select id="wbp-color-dd" aria-label="기타 색상">
      <option value="">색 더보기…</option>
      <option value="#e8590c">오렌지</option>
      <option value="#e67700">앰버</option>
      <option value="#5c940d">라임그린</option>
      <option value="#0ca678">티얼</option>
      <option value="#1098ad">청록</option>
      <option value="#4263eb">인디고</option>
      <option value="#d6336c">딥핑크</option>
      <option value="#adb5bd">회색</option>
      <option value="clear">색 제거</option>
    </select>
  
    <button type="button" data-act="clearColor" title="색 제거">⨯</button>
  </div>

  <script>
    (function patchVerseToolbarColors(){
      const bar  = document.getElementById('wbp-plbar');
      const dd   = document.getElementById('wbp-color-dd');
    
      if(!bar) return;
    
      // 공통: 현재 선택에 지정 색 적용
      function applyColor(color){
        if(!color) return;
        // execCommand foreColor 적용
        document.execCommand('foreColor', false, color);
        // 저장 훅 (당신 프로젝트의 함수가 이미 있다면 그걸 호출)
        try{ setTimeout(window.saveCurrentLineFormatting || (()=>{}), 0); }catch(_){}
      }
    
      // 스와치 클릭 처리 (data-color)
      bar.addEventListener('click', (e)=>{
        const sw = e.target.closest('.color-swatch');
        if(sw?.dataset?.color){
          // 선택 복원 시도(당신의 enableVerseToolbar에서 range 저장/복원 중이면 그대로 사용)
          try{
            // 이미 restoreSel을 구현하셨다면 실행되고, 없으면 무시
            window.restoreSel && window.restoreSel();
          }catch(_){}
          applyColor(sw.dataset.color);
        }
      });
    
      // 드롭다운 변경 처리
      dd?.addEventListener('change', ()=>{
        const val = dd.value;
        if(!val) return;               // "색 더보기…" (빈 값)
        if(val === 'clear'){
          // 색 제거 로직 (inline color를 벗겨냄)
          try{
            const sel = window.getSelection(); if(!sel || sel.rangeCount===0) return;
            const range = sel.getRangeAt(0);
            const frag  = range.cloneContents();
            const div   = document.createElement('div'); div.appendChild(frag);
            div.querySelectorAll('span, font').forEach(n=>{
              if(n.style?.color) n.style.color = '';
              if(n.hasAttribute?.('color')) n.removeAttribute('color');
              if(n.getAttribute?.('style')==='') n.removeAttribute('style');
            });
            range.deleteContents();
            document.execCommand('insertHTML', false, div.innerHTML || div.textContent || '');
          }catch(_){}
          try{ setTimeout(window.saveCurrentLineFormatting || (()=>{}), 0); }catch(_){}
          dd.value = '';               // 초기화
          return;
        }
        // 일반 색상
        try{ window.restoreSel && window.restoreSel(); }catch(_){}
        applyColor(val);
        dd.value = '';                 // 선택 후 초기화
      });
    
      // 기존 바 클릭(굵게/기울임/밑줄) 뒤 저장 훅을 강화
      bar.addEventListener('click', (e)=>{
        const btn = e.target.closest('button');
        if(!btn) return;
        // 굵게/기울임/밑줄/색제거 등 처리 후 저장
        setTimeout(()=>{ try{ (window.saveCurrentLineFormatting||(()=>{}))(); }catch(_){}} ,0);
      });
    })();

    /* ========= 플로팅 툴바 (굵게/기울임/밑줄/색상) ========= */
    (function enableVerseToolbar(){
      const bar = document.getElementById('wbp-plbar');
      const colorInp = document.getElementById('wbp-plcolor');
      if(!bar){ console.warn('[WBP] toolbar element #wbp-plbar not found'); return; }

      const LINE_SELECTOR  = '.pline, p.verse, .verse-line';
      const SCOPE_SELECTOR = '.pcontent, .editor, main, body';

      let savedRange = null;

      function findLineFromSelection(){
        const sel = window.getSelection();
        if(!sel || sel.rangeCount===0) return null;
        const n = sel.getRangeAt(0).commonAncestorContainer;
        const el = (n.nodeType===1 ? n : n.parentElement);
        return el?.closest?.(LINE_SELECTOR) || null;
      }
      function ensureEditableScope(line){
        const scope = line.closest(SCOPE_SELECTOR) || line.parentElement || line;
        if(scope && scope.getAttribute('contenteditable')!=='true'){
          scope.setAttribute('contenteditable','true');
        }
      }
      function hasRealSelection(){
        const sel = window.getSelection();
        return !!(sel && sel.rangeCount && !sel.getRangeAt(0).collapsed);
      }
      function saveSel(){
        const sel = window.getSelection();
        if(sel && sel.rangeCount>0) savedRange = sel.getRangeAt(0).cloneRange();
      }
      function restoreSel(){
        if(!savedRange) return false;
        const sel = window.getSelection();
        sel.removeAllRanges(); sel.addRange(savedRange);
        return true;
      }
      function getSelRect(){
        const sel = window.getSelection();
        if(!sel || sel.rangeCount===0) return null;
        const r = sel.getRangeAt(0).cloneRange();
        let rect = r.getBoundingClientRect();
        if(!rect || (rect.width===0 && rect.height===0)){
          const span = document.createElement('span');
          span.appendChild(document.createTextNode('\u200b'));
          r.insertNode(span);
          rect = span.getBoundingClientRect();
          span.remove();
        }
        return rect;
      }
      function showBarIfLine(){
        if(!hasRealSelection()){ hide(); return; }
        const line = findLineFromSelection();
        if(!line){ hide(); return; }
        ensureEditableScope(line);

        const rect = getSelRect();
        if(!rect){ hide(); return; }

        bar.style.left = (rect.left + rect.width/2) + 'px';
        bar.style.top  = rect.top + 'px';
        bar.hidden = false;
        saveSel();
      }
      function hide(){ bar.hidden = true; }

      bar.addEventListener('mousedown', e=> e.preventDefault());
      bar.addEventListener('click', e=>{
        const btn = e.target.closest('button'); if(!btn) return;
        if(!restoreSel()) return;

        const cmd = btn.dataset.cmd;
        const act = btn.dataset.act;

        if(cmd){
          document.execCommand(cmd,false,null);
          saveSel(); showBarIfLine();
          setTimeout(saveCurrentLineFormatting, 0);
          return;
        }
        if(act==='clearColor'){
          try{
            const sel = window.getSelection(); if(!sel || sel.rangeCount===0) return;
            const range = sel.getRangeAt(0);
            const frag  = range.cloneContents();
            const div   = document.createElement('div'); div.appendChild(frag);
            div.querySelectorAll('span, font').forEach(n=>{
              if(n.style?.color) n.style.color = '';
              if(n.hasAttribute?.('color')) n.removeAttribute('color');
              if(n.getAttribute?.('style')==='') n.removeAttribute('style');
            });
            range.deleteContents();
            document.execCommand('insertHTML', false, div.innerHTML || div.textContent || '');
          }catch(_){}
          saveSel(); showBarIfLine();
          setTimeout(saveCurrentLineFormatting, 0);
        }
      });

      colorInp?.addEventListener('input', ()=>{
        if(!restoreSel()) return;
        document.execCommand('foreColor', false, colorInp.value);
        saveSel(); showBarIfLine();
        setTimeout(saveCurrentLineFormatting, 0);
      });

      document.addEventListener('selectionchange', ()=> setTimeout(showBarIfLine, 0));
      document.addEventListener('mouseup',         ()=> setTimeout(showBarIfLine, 0));
      document.addEventListener('keyup',           ()=> setTimeout(showBarIfLine, 0));
      window.addEventListener('scroll', hide, {passive:true});
      window.addEventListener('resize', hide);

      window.addEventListener('keydown', (e)=>{
        if(!(e.ctrlKey||e.metaKey)) return;
        const k = e.key.toLowerCase();
        if(!['b','i','u'].includes(k)) return;
        if(!findLineFromSelection()) return;
        if(!hasRealSelection()) return;
        e.preventDefault();
        document.execCommand(k==='b'?'bold':k==='i'?'italic':'underline', false, null);
        setTimeout(showBarIfLine, 0);
        setTimeout(saveCurrentLineFormatting, 0);
      });

      window.addEventListener('keydown', (e)=>{
        if(e.altKey && e.key.toLowerCase()==='k'){
          setTimeout(showBarIfLine, 0);
        }
      });
    })();

    /* ========= 버튼 filled-state (요약/단위/전체/주석/설교) ========= */
    function WBP_safe(fn, fallback){ try{ return fn(); }catch(_){ return fallback; } }
    function WBP_paraId(book, chap, paraIdx){
      const para = WBP_safe(()=>BIBLE.books[book][chap].paras[paraIdx], null);
      if(!para) return null;
      return `${book}|${chap}|${para.ref}`;
    }
    function WBP_pickMetaFromParaEl(paraEl){
      const t = paraEl.querySelector('summary .ptitle');
      if(!t) return null;
      const book = t.dataset.book;
      const chap = parseInt(t.dataset.ch, 10);
      const idx  = parseInt(t.dataset.idx, 10);
      if(!book || !Number.isFinite(chap) || !Number.isFinite(idx)) return null;
      return {book, chap, idx};
    }
    function WBP_hasDoc(map, pid){
      const doc = (map||{})[pid];
      if(!doc) return false;
      const body = (doc.body || '').replace(/\s+/g,'').trim();
      const title= (doc.title||'').replace(/\s+/g,'').trim();
      return !!(body || title);
    }
    function WBP_hasSermon(sermonMap, pid){
      const arr = (sermonMap||{})[pid] || [];
      return Array.isArray(arr) && arr.length > 0 && arr.some(it=>{
        const title=(it.title||'').replace(/\s+/g,'').trim();
        const body =(it.body ||'').replace(/\s+/g,'').trim();
        return !!(title || body);
      });
    }
    function WBP_applyFilledToParaEl(paraEl){
      const meta = WBP_pickMetaFromParaEl(paraEl);
      if(!meta) return;
      const pid = WBP_paraId(meta.book, meta.chap, meta.idx);
      if(!pid) return;

      const sermonMap = WBP_safe(()=>JSON.parse(localStorage.getItem(STORAGE_SERMON)||'{}'), {});
      const unitMap   = WBP_safe(()=>JSON.parse(localStorage.getItem(STORAGE_UNIT_CTX)||'{}'), {});
      const wholeMap  = WBP_safe(()=>JSON.parse(localStorage.getItem(STORAGE_WHOLE_CTX)||'{}'), {});
      const commMap   = WBP_safe(()=>JSON.parse(localStorage.getItem(STORAGE_COMMENTARY)||'{}'), {});
      const sumMap    = WBP_safe(()=>JSON.parse(localStorage.getItem(STORAGE_SUMMARY)||'{}'), {});

      const hasSummary    = WBP_hasDoc(sumMap,  pid);
      const hasUnit       = WBP_hasDoc(unitMap, pid);
      const hasWhole      = WBP_hasDoc(wholeMap,pid);
      const hasCommentary = WBP_hasDoc(commMap, pid);
      const hasSermon     = WBP_hasSermon(sermonMap, pid);

      const tb = paraEl.querySelector('.ptoolbar');
      if(!tb) return;

      const btnSummary    = tb.querySelector('.btnSummary');
      const btnUnitCtx    = tb.querySelector('.btnUnitCtx');
      const btnWholeCtx   = tb.querySelector('.btnWholeCtx');
      const btnCommentary = tb.querySelector('.btnCommentary');
      const btnSermon     = tb.querySelector('.sermBtn');

      if(btnSummary)    btnSummary.classList.toggle('filled',    !!hasSummary);
      if(btnUnitCtx)    btnUnitCtx.classList.toggle('filled',    !!hasUnit);
      if(btnWholeCtx)   btnWholeCtx.classList.toggle('filled',   !!hasWhole);
      if(btnCommentary) btnCommentary.classList.toggle('filled', !!hasCommentary);
      if(btnSermon)     btnSermon.classList.toggle('filled',     !!hasSermon);
    }
    function WBP_sweepAll(){
      document.querySelectorAll('#tree details.para').forEach(WBP_applyFilledToParaEl);
    }
    (function(){
      const root = document.getElementById('tree');
      if(!root) return;
      setTimeout(WBP_sweepAll, 200);
      const mo = new MutationObserver(()=> WBP_sweepAll());
      mo.observe(root, {subtree:true, childList:true});
    })();
    (function wrapSavers(){
      const _setSermonMap = window.setSermonMap;
      const _setDocMap    = window.setDocMap;
      if(typeof _setSermonMap === 'function'){
        window.setSermonMap = function(o){
          const r = _setSermonMap.call(this, o);
          const openPara = document.querySelector('#tree details.para[open]') || null;
          if(openPara) WBP_applyFilledToParaEl(openPara);
          setTimeout(WBP_sweepAll, 0);
          return r;
        }
      }
      if(typeof _setDocMap === 'function'){
        window.setDocMap = function(key, obj){
          const r = _setDocMap.call(this, key, obj);
          const openPara = document.querySelector('#tree details.para[open]') || null;
          if(openPara) WBP_applyFilledToParaEl(openPara);
          setTimeout(WBP_sweepAll, 0);
          return r;
        }
      }
    })();
    document.getElementById('tree')?.addEventListener('toggle', (e)=>{
      const para = e.target?.closest?.('details.para');
      if(para && para.open){ WBP_applyFilledToParaEl(para); }
    }, true);
    window.addEventListener('keydown', (e)=>{
      if(e.altKey && e.key.toLowerCase()==='l'){ WBP_sweepAll(); }
    });

    /* ========= 절 서식 영구 보존 ========= */
    const STORAGE_VERSE_FMT = 'wbps.versefmt.v1';

    function getVerseFmtMap(){
      try{ return JSON.parse(localStorage.getItem(STORAGE_VERSE_FMT) || '{}'); }
      catch{ return {}; }
    }
    function setVerseFmtMap(obj){
      localStorage.setItem(STORAGE_VERSE_FMT, JSON.stringify(obj));
    }
    function keyForPline(plineEl){
      try{
        const paraEl = plineEl.closest('details.para');
        if(!paraEl) return null;
        const t = paraEl.querySelector('summary .ptitle');
        if(!t) return null;
        const book = t.dataset.book;
        const chap = parseInt(t.dataset.ch, 10);
        const idx  = parseInt(t.dataset.idx, 10);
        const para = (window.BIBLE?.books?.[book]?.[chap]?.paras || [])[idx];
        if(!para) return null;
        const v = plineEl.dataset.verse;
        if(!v) return null;
        return `${book}|${chap}|${para.ref}|v${v}`;
      }catch(_){ return null; }
    }
    function saveCurrentLineFormatting(){
      const sel = window.getSelection?.();
      if(!sel || !sel.rangeCount) return;
      const n = sel.getRangeAt(0).commonAncestorContainer;
      const el = (n.nodeType === 1 ? n : n.parentElement);
      const line = el?.closest?.('.pline, .verse-line, p.verse');
      if(!line) return;
      const key = keyForPline(line);
      if(!key) return;
      const map = getVerseFmtMap();
      map[key] = line.innerHTML;
      setVerseFmtMap(map);
    }
    function restoreLineFormatting(line){
      const key = keyForPline(line);
      if(!key) return;
      const map = getVerseFmtMap();
      if(map[key]){ line.innerHTML = map[key]; }
    }
    (function watchTreeForNewLines(){
      const root = document.getElementById('tree');
      if(!root) return;
      root.querySelectorAll('.pline, .verse-line, p.verse').forEach(restoreLineFormatting);
      const mo = new MutationObserver((muts)=>{
        for(const m of muts){
          m.addedNodes?.forEach?.(node=>{
            if(!(node instanceof HTMLElement)) return;
            if(node.matches?.('.pline, .verse-line, p.verse')){
              restoreLineFormatting(node);
            }
            node.querySelectorAll?.('.pline, .verse-line, p.verse')?.forEach?.(restoreLineFormatting);
          });
        }
      });
      mo.observe(root, {subtree:true, childList:true});
    })();
    (function hookToolbarSaves(){
      const bar = document.getElementById('wbp-plbar');
      const color = document.getElementById('wbp-plcolor');
      if(bar){
        bar.addEventListener('click', (e)=>{
          const btn = e.target.closest('button');
          if(!btn) return;
          setTimeout(saveCurrentLineFormatting, 0);
        });
      }
      if(color){
        color.addEventListener('input', ()=>{
          setTimeout(saveCurrentLineFormatting, 0);
        });
      }
      document.addEventListener('keyup',  ()=> setTimeout(saveCurrentLineFormatting, 0));
      document.addEventListener('mouseup',()=> setTimeout(saveCurrentLineFormatting, 0));
    })();

    /* ========= 특정 단락 서식 초기화 버튼 주입 ========= */
    function metaFromParaEl(paraEl){
      const t = paraEl.querySelector('summary .ptitle');
      if(!t) return null;
      const book = t.dataset.book;
      const chap = parseInt(t.dataset.ch,10);
      const idx  = parseInt(t.dataset.idx,10);
      if(!book || !Number.isFinite(chap) || !Number.isFinite(idx)) return null;
      return {book,chap,idx};
    }
    function clearFormattingForPara(paraEl){
      const meta = metaFromParaEl(paraEl);
      if(!meta) return alert('단락 정보를 찾을 수 없습니다.');
      const para = window.BIBLE?.books?.[meta.book]?.[meta.chap]?.paras?.[meta.idx];
      if(!para) return alert('성경 본문 데이터가 없습니다.');

      const prefix = `${meta.book}|${meta.chap}|${para.ref}|`;
      const map = getVerseFmtMap();
      const newMap = {};
      let count = 0;
      for(const [k,v] of Object.entries(map)){
        if(k.startsWith(prefix)) { count++; continue; }
        newMap[k]=v;
      }
      setVerseFmtMap(newMap);

      paraEl.querySelectorAll('.pline, .verse-line, p.verse').forEach(line=>{
        const textOnly = line.textContent.trim();
        if(textOnly){ line.innerHTML = textOnly; }
      });

      alert(`'${meta.book} ${meta.chap}장 (${para.ref})' 단락의 서식 ${count}개를 초기화했습니다.`);
    }
    (function injectClearBtn(){
      const root = document.getElementById('tree');
      if(!root) return;
      const addBtn = (tb, paraEl)=>{
        if(tb.querySelector('.btnClearFmt')) return;
        const btn = document.createElement('button');
        btn.className = 'btnClearFmt';
        btn.textContent = '서식초기화';
        btn.title = '이 단락 안의 굵게/기울임/밑줄/색상 서식을 초기화합니다.';
        btn.style.background = '#552222';
        btn.style.color = '#fff';
        btn.style.border = '1px solid #aa4444';
        btn.style.borderRadius = '8px';
        btn.addEventListener('click', ()=> clearFormattingForPara(paraEl));
        tb.appendChild(btn);
      };
      root.querySelectorAll('details.para').forEach(paraEl=>{
        const tb = paraEl.querySelector('.ptoolbar');
        if(tb) addBtn(tb, paraEl);
      });
      const mo = new MutationObserver((muts)=>{
        for(const m of muts){
          m.addedNodes?.forEach?.(n=>{
            if(!(n instanceof HTMLElement)) return;
            const paraEl = n.matches?.('details.para') ? n : n.closest?.('details.para');
            const tb = paraEl?.querySelector?.('.ptoolbar');
            if(paraEl && tb) addBtn(tb, paraEl);
          });
        }
      });
      mo.observe(root, {subtree:true, childList:true});
    })();
  </script>

  <script>
    /* ====== WBP Verse Formatting — Persist & Force-Restore Patch (stable) ====== */
    /* 0) 안전 유틸 */
    const __WBP = {
      q(sel, root=document){ return root.querySelector(sel); },
      qa(sel, root=document){ return Array.from(root.querySelectorAll(sel)); },
      safe(fn, fb){ try{ return fn(); }catch{ return fb; } },
    };
    
    /* 1) 저장소 접근 (기존 키와 호환 유지) */
    const STORAGE_VERSE_FMT = 'wbps.versefmt.v1';
    function getVerseFmtMap(){
      return __WBP.safe(()=>JSON.parse(localStorage.getItem(STORAGE_VERSE_FMT)||'{}'),{});
    }
    function setVerseFmtMap(obj){
      localStorage.setItem(STORAGE_VERSE_FMT, JSON.stringify(obj));
    }
    
    /* 2) 고유키 계산: data-verse 없으면 인덱스 fallback */
    function keyForPlineRobust(plineEl){
      try{
        const paraEl = plineEl.closest('details.para'); if(!paraEl) return null;
        const t = paraEl.querySelector('summary .ptitle'); if(!t) return null;
    
        const book = t.dataset.book;
        const chap = parseInt(t.dataset.ch, 10);
        const idx  = parseInt(t.dataset.idx, 10);
        const para = window.BIBLE?.books?.[book]?.[chap]?.paras?.[idx];
        if(!para) return null;
    
        // 우선 절번호
        const v = plineEl.dataset.verse;
        if (v) return `${book}|${chap}|${para.ref}|v${v}`;
    
        // 절번호가 없으면, 같은 단락 내 라인 인덱스로 fallback
        const lines = Array.from(paraEl.querySelectorAll('.pline, .verse-line, p.verse'));
        const pos = Math.max(0, lines.indexOf(plineEl));
        return `${book}|${chap}|${para.ref}|i${pos}`;
      }catch{ return null; }
    }
    
    /* 3) 저장 훅 (툴바/키입력 직후) */
    function saveCurrentLineFormatting(){
      const sel = window.getSelection?.();
      if(!sel || !sel.rangeCount) return;
      const n = sel.getRangeAt(0).commonAncestorContainer;
      const el = (n.nodeType === 1 ? n : n.parentElement);
      const line = el?.closest?.('.pline, .verse-line, p.verse');
      if(!line) return;
    
      const key = keyForPlineRobust(line);
      if(!key) return;
    
      const map = getVerseFmtMap();
      map[key] = line.innerHTML;  // 서식 포함 저장
      setVerseFmtMap(map);
    }
    
    /* 4) 복원 로직 */
    function restoreLineFormatting(line){
      const key = keyForPlineRobust(line);
      if(!key) return;
      const map = getVerseFmtMap();
      if(map[key]){
        line.innerHTML = map[key];
      }
    }
    
    /* 5) 강제 복원 스윕(초기 + 동적) */
    (function forceRestoreBootStrap(){
      const root = document.getElementById('tree');
      if(!root) return;
    
      const LINE_SEL = '.pline, .verse-line, p.verse';
    
      // (A) 페이지 초기에 렌더가 늦게 오는 경우 대비: 3초간 폴링
      let tries = 0;
      const maxTries = 12; // 12 * 250ms = 3s
      const timer = setInterval(()=>{
        tries++;
        __WBP.qa(LINE_SEL, root).forEach(restoreLineFormatting);
        if(tries >= maxTries) clearInterval(timer);
      }, 250);
    
      // (B) MutationObserver: buildTree/토글/가져오기 후에도 자동 복원
      const mo = new MutationObserver(muts=>{
        for(const m of muts){
          m.addedNodes?.forEach?.(node=>{
            if(!(node instanceof HTMLElement)) return;
            if(node.matches?.(LINE_SEL)) restoreLineFormatting(node);
            node.querySelectorAll?.(LINE_SEL)?.forEach?.(restoreLineFormatting);
          });
        }
      });
      mo.observe(root, {subtree:true, childList:true});
    
      // (C) details 토글 시점에도 복원
      root.addEventListener('toggle', e=>{
        const para = e.target?.closest?.('details.para');
        if(para && para.open){
          __WBP.qa(LINE_SEL, para).forEach(restoreLineFormatting);
        }
      }, true);
    
      // (D) 창 복귀/포커스 시 한 번 더 복원 (앱에 따라 재랜더링이 들어올 수 있음)
      window.addEventListener('focus', ()=>{
        __WBP.qa(LINE_SEL, root).forEach(restoreLineFormatting);
      });
    })();
    
    /* 6) 툴바/입력 이벤트에 저장 연결(이미 있으나 확실히 한 번 더) */
    (function wireSaves(){
      const bar   = document.getElementById('wbp-plbar');
      const color = document.getElementById('wbp-plcolor');
    
      bar?.addEventListener('click', e=>{
        if(e.target.closest('button')) setTimeout(saveCurrentLineFormatting, 0);
      });
      color?.addEventListener('input', ()=>{
        setTimeout(saveCurrentLineFormatting, 0);
      });
    
      // 수동 편집/붙여넣기 등도 커버
      document.addEventListener('keyup',  ()=> setTimeout(saveCurrentLineFormatting, 0));
      document.addEventListener('mouseup',()=> setTimeout(saveCurrentLineFormatting, 0));
    })();
    
    /* 7) (선택) 저장 호출 최소 간격 제한: 잦은 저장을 줄이고 싶으면 주석 해제
    (function throttleSaves(interval = 400){
      const orig = window.saveCurrentLineFormatting;
      if (typeof orig !== 'function') return;
      let last = 0, pending = null;
      window.saveCurrentLineFormatting = function(){
        const now = Date.now(), el = now - last;
        if(el >= interval){ last = now; orig(); }
        else { clearTimeout(pending);
               pending = setTimeout(()=>{ last = Date.now(); orig(); }, interval - el); }
      }
    })(400);
    */
    </script>

  <!-- 기존 앱 스크립트는 마지막에 둡니다 (defer) -->
  <script src="app.js" defer></script>

  <script>
    /* ====== WBP v3: 절문장 서식 저장/복원 안정 패치 (하단에 1번만 삽입) ====== */
    
    /* 0) 전역 키/함수 보장 (중복 방지) */
    window.WBP_FMT_KEY = window.WBP_FMT_KEY || 'wbps.versefmt.v1';
    window.WBP_FMT     = window.WBP_FMT || {
      get(){ try{ return JSON.parse(localStorage.getItem(window.WBP_FMT_KEY)||'{}'); }catch{ return {}; } },
      set(o){ localStorage.setItem(window.WBP_FMT_KEY, JSON.stringify(o)); }
    };
    
    /* 1) 각 절(.pline / .verse-line / p.verse)에 data-verse 자동 보정
          - <sup class="pv">3</sup> 같은 절번호가 있으면 그걸 사용
          - 그래도 없으면 “라인 인덱스”로 대체키 생성 */
    function ensureVerseKeys(root=document){
      root.querySelectorAll('.pline, .verse-line, p.verse').forEach((line, i)=>{
        if(line.dataset.verse) return;
        // 1) sup 안 숫자 찾기
        const sup = line.querySelector('sup, .pv');
        const n1  = sup ? String((sup.textContent||'').trim().match(/^\d+/)?.[0]||'') : '';
        if(n1){ line.dataset.verse = n1; return; }
        // 2) 텍스트 맨 앞 숫자
        const txt = (line.textContent||'').trim();
        const n2  = String(txt.match(/^\d+/)?.[0]||'');
        if(n2){ line.dataset.verse = n2; return; }
        // 3) 최후: 인덱스 기반
        line.dataset.verse = 'idx' + i;
      });
    }
    
    /* 2) 단락 메타 추출 */
    function metaFromParaEl(paraEl){
      const t = paraEl?.querySelector?.('summary .ptitle');
      if(!t) return null;
      const book = t.dataset.book;
      const chap = parseInt(t.dataset.ch,10);
      const idx  = parseInt(t.dataset.idx,10);
      if(!book || !Number.isFinite(chap) || !Number.isFinite(idx)) return null;
      // ref는 BIBLE에서 다시 조회
      const para = window.BIBLE?.books?.[book]?.[chap]?.paras?.[idx];
      if(!para) return null;
      return {book, chap, idx, ref: para.ref};
    }
    
    /* 3) 절 라인 → 고유키 */
    function keyForPline(plineEl){
      try{
        const paraEl = plineEl.closest('details.para');
        if(!paraEl) return null;
        const meta = metaFromParaEl(paraEl);
        if(!meta) return null;
        const v = plineEl.dataset.verse || '';
        if(!v) return null;
        return `${meta.book}|${meta.chap}|${meta.ref}|v${v}`;
      }catch{ return null; }
    }
    
    /* 4) 저장: 현재 선택이 걸린 라인의 innerHTML 그대로 저장 */
    window.saveCurrentLineFormatting = function(){
      const sel = window.getSelection?.();
      if(!sel || !sel.rangeCount) return;
      const n   = sel.getRangeAt(0).commonAncestorContainer;
      const el  = (n.nodeType===1 ? n : n.parentElement);
      const line= el?.closest?.('.pline, .verse-line, p.verse');
      if(!line) return;
      const key = keyForPline(line);
      if(!key) return;              // ← 여기서 null이면 저장이 안 됨(이번 패치로 예방)
      const m = window.WBP_FMT.get();
      m[key]  = line.innerHTML;     // 서식 포함 저장
      window.WBP_FMT.set(m);
    };
    
    /* 5) 복원: 라인이 생기면 저장본으로 덮기 */
    function restoreLineFormatting(line){
      const key = keyForPline(line);
      if(!key) return;
      const m = window.WBP_FMT.get();
      if(m[key]) line.innerHTML = m[key];
    }
    
    /* 6) 초기 스윕 + MutationObserver (buildTree 이후 자동 복원) */
    (function initRestore(){
      const root = document.getElementById('tree') || document;
      // 첫 보정/복원
      ensureVerseKeys(root);
      root.querySelectorAll('.pline, .verse-line, p.verse').forEach(restoreLineFormatting);
      // 이후 동적 추가 감시
      const mo = new MutationObserver(muts=>{
        for(const mu of muts){
          mu.addedNodes?.forEach?.(node=>{
            if(!(node instanceof HTMLElement)) return;
            ensureVerseKeys(node);
            if(node.matches?.('.pline, .verse-line, p.verse')) restoreLineFormatting(node);
            node.querySelectorAll?.('.pline, .verse-line, p.verse')?.forEach?.(restoreLineFormatting);
          });
        }
      });
      mo.observe(root, {subtree:true, childList:true});
    })();
    
    /* 7) 플로팅툴바/편집 입력 후 “즉시 저장 훅” (툴바 코드와 자연 결합) */
    (function hookSaves(){
      const bar = document.getElementById('wbp-plbar');
      // 굵게/기울임/밑줄/스와치/드롭다운/색제거 버튼 클릭 뒤 저장
      bar?.addEventListener('click', ()=> setTimeout(window.saveCurrentLineFormatting, 0));
      // 색 드롭다운(있다면) 변경 뒤 저장
      document.getElementById('wbp-color-dd')?.addEventListener('change', ()=>{
        setTimeout(window.saveCurrentLineFormatting, 0);
      });
      // 사용자가 직접 타이핑/붙여넣기/마우스 조작 후 저장
      const tree = document.getElementById('tree') || document;
      tree.addEventListener('input',   ()=> setTimeout(window.saveCurrentLineFormatting, 0), true);
      tree.addEventListener('keyup',   ()=> setTimeout(window.saveCurrentLineFormatting, 0), true);
      tree.addEventListener('mouseup', ()=> setTimeout(window.saveCurrentLineFormatting, 0), true);
    })();
    
    /* 8) 단락 전체 초기화 버튼이 있다면, data-verse 보정도 같이 수행 */
    (function patchClearBtnSideEffect(){
      document.getElementById('tree')?.addEventListener('click', (e)=>{
        const btn = e.target.closest('.btnClearFmt');
        if(!btn) return;
        const para = btn.closest('details.para');
        setTimeout(()=> ensureVerseKeys(para||document), 0);
      });
    })();
  </script>

</body>
</html>
